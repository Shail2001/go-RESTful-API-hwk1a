# Part 2: Cloud Computing Concepts - Learning Outcomes

## Virtual Machines

A Virtual Machine (VM), as its name suggests, is a virtual computer that behaves like a physical one and runs on the hardware of the host machine. If a local program is running, it goes directly through your physical computer’s OS and is reachable only through localhost (127.0.0.1). Eventually, the other way round is that when the program is running in a VM, it executes on a server that is remote but accessible through the network via a public IP address in a data center. The major differences are: VMs can be accessed anywhere 24/7 and use shared cloud hardware resources, network connectivity is necessary for access, and they work on a pay-as-you-go model, whereas local programs run only when your PC is turned on, use your dedicated hardware, and cost nothing beyond electricity.

## Security Groups and IP Changes

I have to change the EC2 security group inbound rule which only allows SSH traffic from my new IP every time my IP address changes. This is done by going to the AWS Console, navigating to EC2 Security Groups, selecting my instance's security group, editing the inbound rules, and updating the source IP for port 22 (SSH) to my new address. An improved way is to use AWS's "My IP" option while creating the rule, which automatically detects and updates to my current IP address. Alternatively, I could use AWS Systems Manager Session Manager or the EC2 Instance connect which doesn't require opening SSH ports at all.

## Elastic IP Addresses

Every time EC2 instances are stopped and then restarted, they get a new public IP address, which creates access inconsistencies and DNS records issues. An Elastic IP address gets rid of these problems by allocating a static, permanent public IPv4 address that is the same no matter how many times you restart the instance or even if you switch the assignment to another instance. While Elastic IPs are attached to running instances, they are free, but if they are unassigned, attached to stopped instances, or allocated, there is a charge of about $0.005/hour (around $3.60/month). For production environments, it is sometimes recommended to use load balancers with DNS names instead of Elastic IPs, and in addition, it is a good practice to release Elastic IPs when they are not in use in order to avoid incurring unnecessary charges.

## Instance Type Specifications

I picked the t3.micro instance type that offers 2 vCPUs with burstable performance along with 1 GB of RAM and is covered by AWS free tier (750 hours/month for 12 months). The t3 family is a newer generation than the t2 offering the better baseline performance and unlimited burst mode capability. The “burstable” means that the instance is operating at 10% CPU baseline per vCPU but can burst to 100% when required by using the CPU credits which are accrued during idle time. These specifications are of great importance as they influence performance, cost, and scalability directly. The t3.micro, with 2 vCPUs and 1 GB RAM, is good for learning and low-traffic apps, but that it can't still cope with many concurrent requests or perform memory-intensive operations. After the free tier, it will cost you about $7.50 a month, while larger instances like t3.small ($15/month) or t3.medium ($30/month) offer better performance. It is very important to understand instance specs in order to match the resources to the workload requirements and to optimize the cost versus performance.

## GCP vs AWS Deployment

The use of Google Cloud Shell Editor was much more convenient and quicker than that of AWS EC2. Cloud Shell Editor is an online IDE that operates on GCP, which means no local installations or complex configurations are necessary. I only had to clone my GitHub repo into the Cloud Shell environment and run the code just like I would on my local machine with go run ., then I would test it in Shell with curl commands. The whole procedure was about 5 minutes long. On the other hand, AWS EC2 needed manually about 30 minutes for setup which included security groups and key pairs configuration, using PuTTY for SSH access, uploading files via PSCP, installing Go on the Linux server, building the app, and managing the server manually. GCP's Cloud Shell made it possible to have a completely pre-configured development environment in the browser where I could write, run and test the code right away, while AWS EC2 needed a complete infrastructure setup from scratch.

## Testing Methodology

I did functional testing manually and performance testing automatically. For functional testing, I executed curl commands to access each API endpoint (GET /albums, GET /albums/:id, POST /albums) and checked the error management by asking for non-existent album IDs, doing so both on localhost during development and on the EC2 public IP after deployment. For performance testing, I wrote a Python script employing the requests library that made constant HTTP requests to my EC2 instance for 30 seconds while the response times were being recorded. The script successfully completed 290+ requests and provided statistical analysis comprising histograms and scatter plots with the use of matplotlib and numpy. The performance was outstanding according to the results, for example, in one of the tests I got a median response time of 82ms, the 95th percentile at 97.28ms.